#!/bin/bash
#	hooks/post-commit  2.523.1465  2020-02-03T14:51:49.029743-06:00 (CST)  https://github.com/BradleyA/git-TEST-commit-automation.git  master  uadmin  five-rpi3b.cptx86.com 2.522  
#	   testing 
#	hooks/post-commit  2.380.1269  2020-01-26T08:22:10.465746-06:00 (CST)  https://github.com/BradleyA/git-TEST-commit-automation.git  master  uadmin  five-rpi3b.cptx86.com 2.379  
#	   hooks/post-commit   Use short test case name 
#	hooks/post-commit  2.373.1261  2020-01-25T21:40:56.673970-06:00 (CST)  https://github.com/BradleyA/git-TEST-commit-automation.git  master  uadmin  five-rpi3b.cptx86.com 2.372  
#	   hooks/post-commit   Production standard 5.3.559 Copyright  Production standard 1.3.550 DEBUG variable  Production standard 2.3.529 log format 
#	hooks/post-commit  2.328.1206  2020-01-23T23:13:49.393804-06:00 (CST)  https://github.com/BradleyA/git-TEST-commit-automation.git  master  uadmin  five-rpi3b.cptx86.com 2.327  
#	   hooks/post-commit   export REPOSITORY_DIR so test scripts can use it 
###  hooks/post-commit - Create production standard TESTing using .git/hooks #26 
#  post-commit - (git hook) run test cases if found
#      Loop through committed files found in COMMIT_FILE_LIST
#        - Note: pre-commit (git hook) created ${REPOSITORY_DIR}/hooks/COMMIT_FILE_LIST
#          Check if COMMIT_FILE has a 'TEST' directory
#              Create list of test cases
#                  Links *.expected (test case output) to other test cases requiring the same test case output
#                      Loop through _TEST_CASE
#                          Run _TEST_CASE
###  Production standard 3.0 shellcheck
###  Production standard 5.3.559 Copyright                                    # 3.559
#    Copyright (c) 2020 Bradley Allen                                                # 3.555
#    MIT License is online in the repository as a file named LICENSE"         # 3.559
###  Production standard 1.3.550 DEBUG variable                                             # 3.550
#    Order of precedence: environment variable, default code
if [[ "${DEBUG}" == ""  ]] ; then DEBUG="0" ; fi   # 0 = debug off, 1 = debug on, 'export DEBUG=1', 'unset DEBUG' to unset environment variable (bash)
if [[ "${DEBUG}" == "2" ]] ; then set -x    ; fi   # Print trace of simple commands before they are executed
if [[ "${DEBUG}" == "3" ]] ; then set -v    ; fi   # Print shell input lines as they are read
if [[ "${DEBUG}" == "4" ]] ; then set -e    ; fi   # Exit immediately if non-zero exit status
if [[ "${DEBUG}" == "5" ]] ; then set -e -o pipefail ; fi   # Exit immediately if non-zero exit status and exit if any command in a pipeline errors
#
BOLD=$(tput -Txterm bold)
NORMAL=$(tput -Txterm sgr0)
RED=$(tput    setaf 1)
GREEN=$(tput  setaf 2)
YELLOW=$(tput setaf 3)
CYAN=$(tput   setaf 6)
WHITE=$(tput  setaf 7)

#    Date and time function ISO 8601
get_date_stamp() {
  DATE_STAMP=$(date +%Y-%m-%dT%H:%M:%S.%6N%:z)
  TEMP=$(date +%Z)
  DATE_STAMP="${DATE_STAMP} (${TEMP})"
}

#    Fully qualified domain name FQDN hostname
LOCALHOST=$(hostname -f)

#    Version
#    Assumptions for the next two lines of code:  The second line in this script includes the script path & name as the second item and
#    the script version as the third item separated with space(s).  The tool I use is called 'markit'. See example line below:
#       template/template.sh  3.517.783  2019-09-13T18:20:42.144356-05:00 (CDT)  https://github.com/BradleyA/user-files.git  uadmin  one-rpi3b.cptx86.com 3.516  
SCRIPT_NAME=$(head -2 "${0}" | awk '{printf $2}')  #  Different from ${COMMAND_NAME}=$(echo "${0}" | sed 's/^.*\///'), SCRIPT_NAME = includes Git repository directory and can be used any where in script (for dev, test teams)
SCRIPT_VERSION=$(head -2 "${0}" | awk '{printf $3}')
if [[ "${SCRIPT_NAME}" == "" ]] ; then SCRIPT_NAME="${0}" ; fi
if [[ "${SCRIPT_VERSION}" == "" ]] ; then SCRIPT_VERSION="v?.?" ; fi

#    GID
GROUP_ID=$(id -g)

###  Production standard 2.3.529 log format (WHEN WHERE WHAT Version Line WHO UID:GID [TYPE] Message)
new_message() {  #  $1="${LINENO}"  $2="DEBUG INFO ERROR WARN"  $3="message"
  get_date_stamp
  echo -e "${NORMAL}${DATE_STAMP} ${LOCALHOST} ${SCRIPT_NAME}[$$] ${SCRIPT_VERSION} ${1} ${USER} ${UID}:${GROUP_ID} ${BOLD}[${2}]${NORMAL}  ${3}"
}

#    INFO
if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "${YELLOW}INFO${WHITE}" "  Started..." 1>&2 ; fi

###  Production standard 10.0 TESTing 

REPOSITORY_DIR=$(git rev-parse --show-toplevel)
export REPOSITORY_DIR  #  export REPOSITORY_DIR so test scripts can use it
if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  REPOSITORY_DIR  >${REPOSITORY_DIR}<" 1>&2 ; fi
REPOSITORY_DIR_COUNT=$(awk -F"/" '{print NF-1}' <<< "${REPOSITORY_DIR}")  #
REPOSITORY_DIR_COUNT=$((REPOSITORY_DIR_COUNT+1))
export REPOSITORY_DIR_COUNT  #  export number of directories + 1
if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  REPOSITORY_DIR_COUNT  >${REPOSITORY_DIR_COUNT}<" 1>&2 ; fi

if [[ ! -r "${REPOSITORY_DIR}/hooks/COMMIT_FILE_LIST" ]] ; then echo "COMMIT_FILE_LIST is created by pre-commit (git hook) and is required input for this script." ; exit 1 ; fi
COMMIT_FILE_LIST=$(cat "${REPOSITORY_DIR}"/hooks/COMMIT_FILE_LIST)

if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  Files being committed hy ${GIT_AUTHOR_NAME} (${USER}): >${COMMIT_FILE_LIST}<" 1>&2 ; fi
echo    "${BOLD}${YELLOW}"
echo    "'####:'##::: ##:::::::'########:'########::'######::'########:"
echo    ". ##:: ###:: ##:::::::... ##..:: ##.....::'##... ##:... ##..::"
echo    ": ##:: ####: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::"
echo    ": ##:: ## ## ##:::::::::: ##:::: ######:::. ######::::: ##::::"
echo    ": ##:: ##. ####:::::::::: ##:::: ##...:::::..... ##:::: ##::::"
echo    ": ##:: ##:. ###:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::"
echo    "'####: ##::. ##:::::::::: ##:::: ########:. ######::::: ##::::"
echo    "....::..::::..:::::::::::..:::::........:::......::::::..:::::${NORMAL}"

#    Loop through committed files found in COMMIT_FILE_LIST
#    - Note: pre-commit (git hook) created ${REPOSITORY_DIR}/hooks/COMMIT_FILE_LIST
for COMMIT_PATH_FILE_NAME in ${COMMIT_FILE_LIST} ; do
  COMMIT_FILE_NAME=$(echo "${COMMIT_PATH_FILE_NAME}" | rev | cut -d '/' -f 1 | rev)  # Did not use baseline becasue I did not want to eliminate directories with a dot trailing SUFFIX
  COMMIT_PATH="${COMMIT_PATH_FILE_NAME//${COMMIT_FILE_NAME}/}"
  if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  \${COMMIT_PATH_FILE_NAME} >${COMMIT_PATH_FILE_NAME}< \${COMMIT_FILE_NAME} >${COMMIT_FILE_NAME}< \${COMMIT_PATH} >${COMMIT_PATH}< \${COMMIT_PATH}TEST/\${COMMIT_FILE_NAME} >${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}<" 1>&2 ; fi
  #    Check if COMMIT_FILE has a 'TEST' directory
  if [[ -d "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}" ]] ; then
    echo "[${BOLD}${YELLOW}INFO${NORMAL}]         Test case directory found ${COMMIT_PATH}TEST/${BOLD}${GREEN}${COMMIT_FILE_NAME}${NORMAL}, for ${GIT_AUTHOR_NAME} (${USER})." 1>&2
    cd "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}"

    ###  SA (Static Analysis)
    #    run SA-cleanup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" "${REPOSITORY_DIR}"
    fi
    #    run SA-setup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-setup.sh" ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-setup.sh" "${REPOSITORY_DIR}"
    fi
    #    Create list of test cases
    SA_TEST_CASES=$(ls -1 | grep "^SA" | grep -v "\.")
    if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" " \${SA_TEST_CASES} >${SA_TEST_CASES}<" 1>&2 ; fi
    NO_TEST_CASES=$(ls -1 | grep "^SA" | grep -v "\." -c)
    NO_TEST_CASES_PASS=0
    NO_TEST_CASES_FAIL=0
    NO_TEST_CASES_ERROR=0
    TEST_CASES_ERROR_EXIT_CODE=""
    RUN_SA_CLEANUP=0  #  run SA-cleanup.sh again (0=no, 1=yes)  #36
    #    Loop through test cases
    for SA_TEST_CASE in ${SA_TEST_CASES} ; do
      #    Run SA_TEST_CASE(s)
      if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  \${REPOSITORY_DIR}/\${COMMIT_PATH}TEST/\${COMMIT_FILE_NAME}/\${SA_TEST_CASE} >${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/${SA_TEST_CASE}< \${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME} >${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME}<" 1>&2 ; fi
      TEST_CASE="${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/${SA_TEST_CASE} ${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME}"
      eval "${TEST_CASE}"
      EXIT_CODE=${?}
      if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  \${EXIT_CODE} >${EXIT_CODE}<" 1>&2 ; fi
      if [[ ${EXIT_CODE} -eq 0 ]] ; then
        NO_TEST_CASES_PASS=$((NO_TEST_CASES_PASS+1))
      elif [[ ${EXIT_CODE} -eq 1 ]] ; then
        NO_TEST_CASES_FAIL=$((NO_TEST_CASES_FAIL+1))
      else
        NO_TEST_CASES_ERROR=$((NO_TEST_CASES_ERROR+1))
        TEST_CASES_ERROR_EXIT_CODE="${TEST_CASES_ERROR_EXIT_CODE}${EXIT_CODE} "
      fi
    done
    #    run SA-cleanup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" ]] && [[ ${NO_TEST_CASES_FAIL} == 0 ]] && [[ ${NO_TEST_CASES_ERROR} == 0 ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" "${REPOSITORY_DIR}"
      RUN_SA_CLEANUP=1  #  run SA-cleanup.sh again (0=no, 1=yes)  #36
    fi
    echo -e "\n     SA: ${BOLD}${YELLOW}${COMMIT_FILE_NAME}${NORMAL}\n   Number of test cases = ${BOLD}${NO_TEST_CASES}${NORMAL}\n   Number of test cases pass = ${BOLD}${GREEN}${NO_TEST_CASES_PASS}${NORMAL}\n   Number of test cases fail = ${BOLD}${RED}${NO_TEST_CASES_FAIL}${NORMAL}\n   Number of test cases error = ${BOLD}${CYAN}${NO_TEST_CASES_ERROR}${NORMAL}"
    echo  "${TEST_CASES_ERROR_EXIT_CODE}" | tr ' ' '\n' | grep '[^[:blank:]]' | sort | uniq -c | sort -k 2 -n  #  List error exit codes and how many of each exit code

    ###  FVT (Function Verification Test)
    #    run FVT-cleanup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-cleanup.sh" ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-cleanup.sh" "${REPOSITORY_DIR}"
    fi
    #    run FVT-setup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-setup.sh" ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-setup.sh" "${REPOSITORY_DIR}"
    fi
    #    Create list of FVT test cases
    FVT_TEST_CASES=$(ls -1 | grep "^FVT" | grep -v "\.")
    if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  \${FVT_TEST_CASES} >${FVT_TEST_CASES}<" 1>&2 ; fi
    NO_TEST_CASES=$(ls -1 | grep "^FVT" | grep -v "\." -c)
    NO_TEST_CASES_PASS=0
    NO_TEST_CASES_FAIL=0
    NO_TEST_CASES_ERROR=0
    TEST_CASES_ERROR_EXIT_CODE=""
    #    Loop through FVT_TEST_CASES
    for FVT_TEST_CASE in ${FVT_TEST_CASES} ; do
      #    Run FVT_TEST_CASE(s)
      if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  \${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME} >${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME}<" 1>&2 ; fi
      TEST_CASE="${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/${FVT_TEST_CASE} ${REPOSITORY_DIR}/${COMMIT_PATH_FILE_NAME}"
      eval "${TEST_CASE}"
      EXIT_CODE=${?}
      if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  \${EXIT_CODE} >${EXIT_CODE}<" 1>&2 ; fi
      if [[ ${EXIT_CODE} -eq 0 ]] ; then
        NO_TEST_CASES_PASS=$((NO_TEST_CASES_PASS+1))
      elif  [[ ${EXIT_CODE} -eq 1 ]] ; then
        NO_TEST_CASES_FAIL=$((NO_TEST_CASES_FAIL+1))
      else
        NO_TEST_CASES_ERROR=$((NO_TEST_CASES_ERROR+1))
        TEST_CASES_ERROR_EXIT_CODE="${TEST_CASES_ERROR_EXIT_CODE}${EXIT_CODE} "
      fi
    done
    #    run FVT-cleanup.sh if found
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-cleanup.sh" ]] && [[ ${NO_TEST_CASES_FAIL} == 0 ]] && [[ ${NO_TEST_CASES_ERROR} == 0 ]] ; then
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/FVT-cleanup.sh" "${REPOSITORY_DIR}"
    fi
    echo -e "\n     FVT: ${BOLD}${YELLOW}${COMMIT_FILE_NAME}${NORMAL}\n   Number of test cases = ${BOLD}${NO_TEST_CASES}${NORMAL}\n   Number of test cases pass = ${BOLD}${GREEN}${NO_TEST_CASES_PASS}${NORMAL}\n   Number of test cases fail = ${BOLD}${RED}${NO_TEST_CASES_FAIL}${NORMAL}\n   Number of test cases error = ${BOLD}${CYAN}${NO_TEST_CASES_ERROR}${NORMAL}"
    echo  "${TEST_CASES_ERROR_EXIT_CODE}" | tr ' ' '\n' | grep '[^[:blank:]]' | sort | uniq -c | sort -k 2 -n  #  List error exit codes and how many of each exit code
    if [[ -s "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" ]] && [[ ${RUN_SA_CLEANUP} == 1 ]] ; then #  run SA-cleanup.sh again (0=no, 1=yes)  #36
      "${REPOSITORY_DIR}/${COMMIT_PATH}TEST/${COMMIT_FILE_NAME}/SA-cleanup.sh" "${REPOSITORY_DIR}"
    fi
  else
    echo "[${BOLD}${YELLOW}INFO${NORMAL}]         ${BOLD}${RED}No${NORMAL} test case directory found ${COMMIT_PATH}TEST/${BOLD}${CYAN}${COMMIT_FILE_NAME}${NORMAL}, for ${GIT_AUTHOR_NAME}."
  fi
done
if [[ "${DEBUG}" == "0" ]] ; then  rm "${REPOSITORY_DIR}"/hooks/COMMIT_FILE_LIST ; fi #  Remove COMMIT_FILE_LIST if NOT in DEBUG

#    Process times
echo -e "${BOLD}${YELLOW}\n     CPU Time    \n  user     sys${CYAN}"
times
echo -e "${NORMAL}\n"

###  Add code here to run additional post-commit hooks

#
if [[ "${DEBUG}" == "1" ]] ; then new_message "${LINENO}" "DEBUG" "  Operation finished." 1>&2 ; fi
###
